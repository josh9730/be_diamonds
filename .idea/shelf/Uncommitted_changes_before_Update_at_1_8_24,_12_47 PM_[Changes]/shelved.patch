Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import asyncio\nimport logging\nfrom pathlib import Path\n\nfrom textual import on, work\nfrom textual.app import App, ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import Container, Horizontal\nfrom textual.reactive import reactive\nfrom textual.validation import Function\nfrom textual.widgets import Button, Footer, Header, Input, Label, Rule\n\nfrom src import data, ss, utils\nfrom src.constants import *\nfrom src.screens import Browser, ErrApp, Output, Waiting\n\nLOG_DIR = Path(\"logs/\")\nif not LOG_DIR.exists():\n    LOG_DIR.mkdir()\n\nlogging.basicConfig(filename=f\"logs/{utils.TODAY}.log\", filemode=\"w\")\n\n\nclass MainApp(App):\n    CSS_PATH = \"src/gui.tcss\"\n    BINDINGS = [\n        Binding(key=\"q\", action=\"quit\", description=\"Quit the app\"),\n    ]\n    ENABLE_COMMAND_PALETTE = False\n\n    ss_name = utils.load_constants()[\"sheet\"]\n    csv = reactive(utils.get_latest_csv())\n    date = reactive(utils.TODAY)\n    ssheet = None\n    df = None\n\n    def compose(self) -> ComposeResult:\n        yield Header()\n\n        with Container():\n            yield Label(\"Smartsheet Name\")\n            yield Input(id=\"sheet\", value=self.ss_name, placeholder=\"Enter the smartsheet to upload to...\")\n            yield Rule(line_style=\"heavy\")\n            yield Label(\"CSV to Upload. Defaults to most recent CSV.\")\n            with Horizontal():\n                yield Input(\n                    id=\"file\",\n                    value=\"\",\n                    placeholder=\"Enter the latest CSV file...\",\n                    validators=[Function(utils.is_valid_file, \"Not a valid file.\")],\n                    classes=\"validinput\",\n                )\n                yield Button(\"Get Recent\", id=\"recent\", variant=\"default\")\n                yield Button(\"Browse\", id=\"browse\", variant=\"primary\")\n            yield Rule(line_style=\"heavy\")\n\n        with Container():\n            yield Label(\"Date for the upload.\")\n            with Horizontal():\n                yield Input(\n                    id=\"date\",\n                    placeholder=\"Enter date for upload...\",\n                    validators=[Function(utils.is_valid_date, \"Not a valid date.\")],\n                    classes=\"validinput\",\n                )\n                yield Button(\"Today\", id=\"today\", variant=\"default\")\n            yield Rule(line_style=\"heavy\")\n            with Horizontal():\n                yield Button(\"Submit\", id=\"submit\", variant=\"success\")\n                yield Button(\"Exit\", id=\"exit\", variant=\"error\")\n\n        yield Footer()\n\n    def on_mount(self) -> None:\n        self.title = UI_TITLE\n        self.query_one(\"#file\").focus()\n\n    @on(Input.Changed, \"#validinput\")\n    def show_invalid_reasons(self, event: Input.Changed) -> None:\n        \"\"\"Updates the UI to show the reasons why validation failed.\"\"\"\n\n        def update_label(control: str, msg: str) -> None:\n            self.query_one(f\"#{control.id}_label\").update(msg)\n\n        if not event.validation_result.is_valid:\n            update_label(event.control, event.validation_result.failure_descriptions[0])\n        else:\n            update_label(event.control, \"Valid\")\n\n    @on(Button.Pressed, \"#submit\")\n    def submit(self) -> None:\n        file = self.query_one(\"#file\")\n        date = self.query_one(\"#date\")\n        if all((file.value, date.value)) and all((file.is_valid, date.is_valid)):\n            self.csv = utils.INPUTS_DIR + file.value\n            self.date = date.value\n            self.ss_name = self.query_one(\"#sheet\").value\n            self.main()\n\n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        def file_input(val: Path) -> None:\n            if val:\n                self.query_one(\"#file\").value = val.name\n\n        match event.button.id:\n            case \"recent\":\n                self.query_one(\"#file\").value = self.csv\n            case \"browse\":\n                self.push_screen(Browser(), file_input)\n            case \"today\":\n                self.query_one(\"#date\").value = self.date\n            case \"exit\":\n                self.app.exit()\n\n    @work\n    async def main(self) -> None:\n        \"\"\"Main function to process data.\n\n        - creates the DataFrame and initializes smartsheets\n        - get initial data from SS needed for processing the comparison data\n            - these are values that are being compared to the current data using data from the smartsheet\n            - i.e. previous uploads\n        - upload all new vendors (i.e. not present on smartsheet)\n        - update DF with comparison data\n        - update smartsheet\n\n        All exceptions are sent to log, and the app is exited with return_code 4 to trigger the error app.\n        Note: Using worker.error does not capture the actual exception raised, only the worker's traceback\n              In order to both log the exception and trigger the error screen, a try/except block was used here\n        \"\"\"\n        try:\n            await self.push_screen(Waiting())\n\n            await asyncio.gather(self.get_df(), self.get_ss())\n            self.ssheet.get_parents_and_first_child_data({\"Prev Video\": SS_VIDEO_TRUE, \"Prev Inven\": SS_PERC_INV})\n            new_vendors = self.load_new_vendors()\n            self.df = data.add_comparison_columns(self.df, self.ssheet.previous_values)\n            utils.save_df_output(self.df)\n\n            exit()\n\n            self.update_smartsheet()\n\n            self.pop_screen()\n            # await self.push_screen(Output(utils.create_markdown(new_vendors, self.date)))\n            await self.push_screen(Output(new_vendors))\n\n            utils.update_csv_isoformat(self.csv, self.date)\n            utils.save_constants({\"sheet\": self.ss_name})\n\n        except Exception as err:\n            logging.exception(err, exc_info=True, stack_info=True)\n            self.exit(return_code=4, message=err)\n\n    async def get_df(self) -> None:\n        \"\"\"Initialize dataframe.\"\"\"\n        self.df = data.create_output_df(self.csv, self.date)\n\n    async def get_ss(self) -> None:\n        \"\"\"Initialize smartsheet.\"\"\"\n        self.ssheet = ss.SSheet()\n        self.ssheet.get_sheet(self.ss_name)\n\n    def load_new_vendors(self) -> list[str | None]:\n        \"\"\"Push new vendors to the sheet.\n\n        Returns a list of vendors or empty list\n        \"\"\"\n        ss_vendors = list(self.ssheet.parent_rows.keys())\n        new_vendors = utils.filter_list(self.df[SS_VENDOR], ss_vendors)\n        if new_vendors:\n            for vendor_val in new_vendors:\n                self.ssheet.add_row_single_col_single_val(SS_VENDOR, vendor_val, update_parents=True)\n            return new_vendors\n        return []\n\n    def update_smartsheet(self) -> None:\n        \"\"\"Iterates over DataFrame and uploads by row by row. API does not allow rows with differing parentIds to be\n        added in same request.\n\n        - New rows are simply added as the first child row under that parent.\n        - Creates row_vals for the row, which are a list of cells. Each cell element will have the column_name and\n          value fields\n        - This is sent to the smartsheet method along with the parent name, i.e. the Vendor (df_row[0])\n        \"\"\"\n        df_cols = list(self.df.columns)\n        for _, df_row in self.df.iterrows():\n            row_vals = []\n            for i, col in enumerate(df_cols):\n                row_vals.append({\"col_name\": col, \"value\": df_row[i]})\n\n            self.ssheet.add_child_rows(row_vals, df_row[0])\n\n\napp = MainApp()\n\nif __name__ == \"__main__\":\n    a = app.run()\n    if app.return_code == 4:\n        ErrApp().run()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision b3496f3d5c1993a54495d77a2eb7e05dcdb5f984)
+++ b/main.py	(date 1704746755572)
@@ -137,12 +137,8 @@
             self.df = data.add_comparison_columns(self.df, self.ssheet.previous_values)
             utils.save_df_output(self.df)
 
-            exit()
-
             self.update_smartsheet()
-
             self.pop_screen()
-            # await self.push_screen(Output(utils.create_markdown(new_vendors, self.date)))
             await self.push_screen(Output(new_vendors))
 
             utils.update_csv_isoformat(self.csv, self.date)
